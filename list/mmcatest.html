<script>
  // UUID 기준이 동일하다는 전제하에 Major:Minor → 작품명 매핑
  const artworkMap = {
    "40011:54726": "4. 동으로 동으로",
    "40011:54699": "1. 우제류를 위하여",
    "40011:45942": "2. 마두",
    "40011:46043": "3. 트리",
    "40011:45678": "5. 보이스 모자",
    "40011:56789": "6. 비상 (1983)",
    "40011:67890": "7. 오호라 나는 곤고한 사람이로다",
    "40011:78901": "8. 그림자를 삼키다",
    "40011:89012": "9. 번역된 도자기"
    // 실제 MINOR 값으로 교체 필요
  };

  const devicesMap = new Map();

  function renderList() {
    const ul = document.getElementById('bleList');
    ul.innerHTML = "";

    const sorted = [...devicesMap.entries()]
      .sort((a, b) => b[1].rssi - a[1].rssi);

    for (const [title, info] of sorted) {
      const li = document.createElement('li');
      li.textContent = `${title} - RSSI: ${info.rssi} dBm`;
      ul.appendChild(li);
    }
  }

  document.getElementById('bleScanBtn').addEventListener('click', async () => {
    const bleList = document.getElementById('bleList');
    bleList.innerHTML = "";

    if (!navigator.bluetooth || !navigator.bluetooth.requestLEScan) {
      console.error("Web Bluetooth LE Scan not supported.");
      return;
    }

    try {
      const scan = await navigator.bluetooth.requestLEScan({
        acceptAllAdvertisements: true
      });

      navigator.bluetooth.addEventListener('advertisementreceived', (event) => {
        const rssi = event.rssi;

        // iBeacon은 manufacturerData에서 파싱해야 함
        const manuData = event.manufacturerData.get(0x004C); // Apple ID for iBeacon
        if (!manuData) return;

        const data = new DataView(manuData.buffer);

        // UUID (16 bytes: offset 2~17)
        const uuid = [...Array(16)].map((_, i) =>
          data.getUint8(i + 2).toString(16).padStart(2, "0")
        ).join("");

        // Major (2 bytes @ offset 18), Minor (2 bytes @ offset 20)
        const major = data.getUint16(18);
        const minor = data.getUint16(20);
        const key = `${major}:${minor}`;

        if (artworkMap[key]) {
          const title = artworkMap[key];
          console.log(`🎯 ${title} (RSSI: ${rssi})`);
          devicesMap.set(title, { rssi, timestamp: Date.now() });
          renderList();
        } else {
          console.log(`⚠️ Unknown beacon - UUID: ${uuid}, Major: ${major}, Minor: ${minor}, RSSI: ${rssi}`);
        }
      });

      setTimeout(() => {
        scan.stop();
        console.log("BLE scan stopped.");
      }, 15000);

    } catch (err) {
      console.error('BLE scan error:', err);
    }
  });

  // 마이크 관련 부분은 그대로 유지
  async function listMicDevices() {
    try {
      await navigator.mediaDevices.getUserMedia({ audio: true });
      const devices = await navigator.mediaDevices.enumerateDevices();
      const micList = document.getElementById('micList');
      micList.innerHTML = "";

      devices
        .filter(d => d.kind === 'audioinput')
        .forEach(d => {
          const option = document.createElement('option');
          option.value = d.deviceId;
          option.textContent = d.label || `Microphone ${d.deviceId}`;
          micList.appendChild(option);
        });
    } catch (err) {
      console.error('Microphone error:', err);
    }
  }

  async function testMic() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mediaRecorder = new MediaRecorder(stream);
      const audioChunks = [];

      mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
      mediaRecorder.onstop = () => {
        const audioBlob = new Blob(audioChunks);
        const audioUrl = URL.createObjectURL(audioBlob);
        const audio = document.getElementById('player');
        audio.src = audioUrl;
        audio.style.display = 'block';
        audio.play();
      };

      mediaRecorder.start();
      console.log("Recording started...");
      setTimeout(() => mediaRecorder.stop(), 3000);
    } catch (err) {
      console.error('Recording failed:', err);
    }
  }
</script>
